SET statement_timeout = 0;

SET lock_timeout = 0;

SET idle_in_transaction_session_timeout = 0;

SET client_encoding = 'UTF8';

SET standard_conforming_strings = ON;

SELECT pg_catalog.set_config('search_path', '', false);

SET check_function_bodies = false;

SET xmloption = content;

SET client_min_messages = warning;

SET row_security = off;

COMMENT ON SCHEMA "public" IS 'standard public schema';

CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";

CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "pgjwt" WITH SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";

CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";

CREATE OR REPLACE FUNCTION "public"."handle_new_game"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER
SET "search_path" TO '' AS $$begin WITH random_words AS (
    SELECT row_number() over () AS row_num,
      id
    FROM public.word
    ORDER BY RANDOM()
  ),
  random_colors AS (
    SELECT row_number() over () AS row_num,
      color
    FROM (
        SELECT 'red' AS color
        FROM GENERATE_SERIES(1, 8)
        UNION ALL
        SELECT 'blue' AS color
        FROM GENERATE_SERIES(1, 8)
        UNION ALL
        SELECT 'neutral' AS color
        FROM GENERATE_SERIES(1, 7)
        UNION ALL
        SELECT 'death' AS color
        FROM GENERATE_SERIES(1, 1)
        UNION ALL
        SELECT CASE
            WHEN RANDOM() < 0.5 THEN 'red'
            ELSE 'blue'
          END AS color
        FROM GENERATE_SERIES(1, 1)
      ) t1
    ORDER BY RANDOM()
  )
INSERT INTO public.tile (game_id, position, word_id, team)
SELECT new.id,
  row_number() over () AS position,
  w.id AS word_id,
  c.color AS team
FROM random_words w
  JOIN random_colors c USING (row_num);

UPDATE public.room
SET current_game_id = new.id
WHERE room.id = new.room_id;

RETURN new;

END $$;

ALTER FUNCTION "public"."handle_new_game"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."handle_new_room"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER
SET "search_path" TO '' AS $$begin
INSERT INTO public.game (room_id)
VALUES (new.id);

RETURN new;

END;

$$;

ALTER FUNCTION "public"."handle_new_room"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."handle_new_user"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER
SET "search_path" TO '' AS $$ BEGIN
INSERT INTO public.player (id, name)
VALUES (new.id, 'Player');

RETURN new;

END;

$$;

ALTER FUNCTION "public"."handle_new_user"() OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";

CREATE TABLE IF NOT EXISTS "public"."game" (
  "id" bigint NOT NULL,
  "created_at" timestamp WITH time zone DEFAULT "now"() NOT NULL,
  "room_id" bigint,
  "is_complete" boolean DEFAULT false NOT NULL,
  "code" "uuid" DEFAULT "gen_random_uuid"()
);

ALTER TABLE "public"."game" OWNER TO "postgres";

ALTER TABLE "public"."game"
ALTER COLUMN "id"
ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."game_id_seq" START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1
  );

CREATE TABLE IF NOT EXISTS "public"."player" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "created_at" timestamp WITH time zone DEFAULT "now"() NOT NULL,
  "name" character varying NOT NULL,
  "current_room_id" bigint,
  "team" character varying,
  "is_spymaster" boolean DEFAULT false
);

ALTER TABLE "public"."player" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."room" (
  "id" bigint NOT NULL,
  "code" character varying NOT NULL,
  "created_at" timestamp WITH time zone DEFAULT "now"() NOT NULL,
  "current_game_id" bigint
);

ALTER TABLE "public"."room" OWNER TO "postgres";

ALTER TABLE "public"."room"
ALTER COLUMN "id"
ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."room_id_seq" START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1
  );

CREATE TABLE IF NOT EXISTS "public"."tile" (
  "id" bigint NOT NULL,
  "created_at" timestamp WITH time zone DEFAULT "now"() NOT NULL,
  "word_id" bigint NOT NULL,
  "game_id" bigint NOT NULL,
  "team" character varying NOT NULL,
  "is_selected" boolean DEFAULT false,
  "position" bigint NOT NULL
);

ALTER TABLE "public"."tile" OWNER TO "postgres";

ALTER TABLE "public"."tile"
ALTER COLUMN "id"
ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."tile_id_seq" START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1
  );

CREATE TABLE IF NOT EXISTS "public"."word" (
  "id" bigint NOT NULL,
  "created_at" timestamp WITH time zone DEFAULT "now"() NOT NULL,
  "word" character varying NOT NULL
);

ALTER TABLE "public"."word" OWNER TO "postgres";

ALTER TABLE "public"."word"
ALTER COLUMN "id"
ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."word_id_seq" START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1
  );

ALTER TABLE ONLY "public"."game"
ADD CONSTRAINT "game_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."player"
ADD CONSTRAINT "player_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."room"
ADD CONSTRAINT "room_code_key" UNIQUE ("code");

ALTER TABLE ONLY "public"."room"
ADD CONSTRAINT "room_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."tile"
ADD CONSTRAINT "tile_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."word"
ADD CONSTRAINT "word_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."word"
ADD CONSTRAINT "word_word_key" UNIQUE ("word");

CREATE OR REPLACE TRIGGER "on_game_created"
AFTER
INSERT ON "public"."game" FOR EACH ROW EXECUTE FUNCTION "public"."handle_new_game"();

CREATE OR REPLACE TRIGGER "on_room_created"
AFTER
INSERT ON "public"."room" FOR EACH ROW EXECUTE FUNCTION "public"."handle_new_room"();

ALTER TABLE ONLY "public"."game"
ADD CONSTRAINT "game_room_id_fkey" FOREIGN KEY ("room_id") REFERENCES "public"."room"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."player"
ADD CONSTRAINT "player_current_room_id_fkey" FOREIGN KEY ("current_room_id") REFERENCES "public"."room"("id") ON DELETE
SET NULL;

ALTER TABLE ONLY "public"."room"
ADD CONSTRAINT "room_current_game_id_fkey" FOREIGN KEY ("current_game_id") REFERENCES "public"."game"("id") ON DELETE
SET NULL;

ALTER TABLE ONLY "public"."tile"
ADD CONSTRAINT "tile_game_id_fkey" FOREIGN KEY ("game_id") REFERENCES "public"."game"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."tile"
ADD CONSTRAINT "tile_word_id_fkey" FOREIGN KEY ("word_id") REFERENCES "public"."word"("id");

CREATE POLICY "Enable insert for authenticated users only" ON "public"."game" FOR
INSERT TO "authenticated" WITH CHECK (TRUE);

CREATE POLICY "Enable insert for authenticated users only" ON "public"."player" FOR
INSERT TO "authenticated" WITH CHECK (
    (
      (
        SELECT "auth"."uid"() AS "uid"
      ) = "id"
    )
  );

CREATE POLICY "Enable insert for authenticated users only" ON "public"."room" FOR
INSERT TO "authenticated" WITH CHECK (TRUE);

CREATE POLICY "Enable update for authenticated users" ON "public"."game" FOR
UPDATE TO "authenticated" USING (TRUE);

CREATE POLICY "Enable update for authenticated users" ON "public"."tile" FOR
UPDATE TO "authenticated" USING (TRUE);

CREATE POLICY "Games are viewable by everyone" ON "public"."game" FOR
SELECT USING (TRUE);

CREATE POLICY "Public profiles are viewable by everyone." ON "public"."player" FOR
SELECT USING (TRUE);

CREATE POLICY "Rooms are viewable by everyone" ON "public"."room" FOR
SELECT USING (TRUE);

CREATE POLICY "Tiles are viewable by everyone" ON "public"."tile" FOR
SELECT USING (TRUE);

CREATE POLICY "Users can update own profile." ON "public"."player" FOR
UPDATE USING (
    (
      (
        SELECT "auth"."uid"() AS "uid"
      ) = "id"
    )
  );

CREATE POLICY "Words are viewable by everyone" ON "public"."word" FOR
SELECT USING (TRUE);

ALTER TABLE "public"."game" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."player" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."room" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."tile" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."word" ENABLE ROW LEVEL SECURITY;

ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";

ALTER PUBLICATION "supabase_realtime"
ADD TABLE ONLY "public"."game";

ALTER PUBLICATION "supabase_realtime"
ADD TABLE ONLY "public"."player";

ALTER PUBLICATION "supabase_realtime"
ADD TABLE ONLY "public"."room";

ALTER PUBLICATION "supabase_realtime"
ADD TABLE ONLY "public"."tile";

GRANT USAGE ON SCHEMA "public" TO "postgres";

GRANT USAGE ON SCHEMA "public" TO "anon";

GRANT USAGE ON SCHEMA "public" TO "authenticated";

GRANT USAGE ON SCHEMA "public" TO "service_role";

GRANT ALL ON FUNCTION "public"."handle_new_game"() TO "anon";

GRANT ALL ON FUNCTION "public"."handle_new_game"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."handle_new_game"() TO "service_role";

GRANT ALL ON FUNCTION "public"."handle_new_room"() TO "anon";

GRANT ALL ON FUNCTION "public"."handle_new_room"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."handle_new_room"() TO "service_role";

GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "anon";

GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "service_role";

GRANT ALL ON TABLE "public"."game" TO "anon";

GRANT ALL ON TABLE "public"."game" TO "authenticated";

GRANT ALL ON TABLE "public"."game" TO "service_role";

GRANT ALL ON SEQUENCE "public"."game_id_seq" TO "anon";

GRANT ALL ON SEQUENCE "public"."game_id_seq" TO "authenticated";

GRANT ALL ON SEQUENCE "public"."game_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."player" TO "anon";

GRANT ALL ON TABLE "public"."player" TO "authenticated";

GRANT ALL ON TABLE "public"."player" TO "service_role";

GRANT ALL ON TABLE "public"."room" TO "anon";

GRANT ALL ON TABLE "public"."room" TO "authenticated";

GRANT ALL ON TABLE "public"."room" TO "service_role";

GRANT ALL ON SEQUENCE "public"."room_id_seq" TO "anon";

GRANT ALL ON SEQUENCE "public"."room_id_seq" TO "authenticated";

GRANT ALL ON SEQUENCE "public"."room_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."tile" TO "anon";

GRANT ALL ON TABLE "public"."tile" TO "authenticated";

GRANT ALL ON TABLE "public"."tile" TO "service_role";

GRANT ALL ON SEQUENCE "public"."tile_id_seq" TO "anon";

GRANT ALL ON SEQUENCE "public"."tile_id_seq" TO "authenticated";

GRANT ALL ON SEQUENCE "public"."tile_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."word" TO "anon";

GRANT ALL ON TABLE "public"."word" TO "authenticated";

GRANT ALL ON TABLE "public"."word" TO "service_role";

GRANT ALL ON SEQUENCE "public"."word_id_seq" TO "anon";

GRANT ALL ON SEQUENCE "public"."word_id_seq" TO "authenticated";

GRANT ALL ON SEQUENCE "public"."word_id_seq" TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON SEQUENCES TO "postgres";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON SEQUENCES TO "anon";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON SEQUENCES TO "authenticated";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON SEQUENCES TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON FUNCTIONS TO "postgres";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON FUNCTIONS TO "anon";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON FUNCTIONS TO "authenticated";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON FUNCTIONS TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON TABLES TO "postgres";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON TABLES TO "anon";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON TABLES TO "authenticated";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON TABLES TO "service_role";

RESET ALL;